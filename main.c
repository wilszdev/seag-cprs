/*
seag-cprs
Copyright (C) 2024  wilszdev

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ERR_OK          0x00
#define ERR_USAGE       0x01
#define ERR_CPRS_FILE   0x02
#define ERR_UNCPRS      0x08
#define ERR_OUT_FILE    0x10

#define FILE_READ_INCREMENT 0x1000

static void* read_file(char* path, size_t* sizeOut);
static int write_file(char* path, void* data, size_t size);
static void* decompress(uint32_t* data, size_t sizeBytes, size_t* sizeOut);

#define CPRS_SIG ((uint32_t)0x53525043)
#define CPRS_TERM 0x10002

static const uint8_t CPRS_TABLE[768];

int main(int argc, char** argv) {
    if (argc != 2 && argc != 3) {
        fprintf(stderr, "Usage: %s INPUTFILE [OUTPUTFILE]\n", argv[0]);
        return ERR_USAGE;
    }

    size_t compressedSize = 0;
    void* compressed = read_file(
            (argv[1][0] == '-' && argv[1][1] == 0) ? 0 : argv[1],
            &compressedSize);

    if (!compressed) {
        return ERR_CPRS_FILE;
    }

    size_t decompressedSize = 0;
    void* decompressed = decompress(compressed, compressedSize, &decompressedSize);

    free(compressed);
    compressed = 0;

    if (!decompressed) {
        return ERR_UNCPRS;
    }

    int success = write_file(
            argc == 3 ? argv[2] : 0,
            decompressed,
            decompressedSize);

    free(decompressed);

    return success ? ERR_OK : ERR_OUT_FILE;
}

static void* read_file(char* path, size_t* sizeOut) {
    FILE* file = path ? fopen(path, "rb") : stdin;
    if (!file) {
        fprintf(stderr, "Error: Unable to open file %s\n", path);
        return 0;
    }

    uint8_t* buffer = 0;
    size_t bufferSize = 0;
    size_t totalBytesRead = 0;

    size_t bytesRead = 0;
    do {
        totalBytesRead += bytesRead;

        if (totalBytesRead >= bufferSize) {
            buffer = realloc(buffer, bufferSize + FILE_READ_INCREMENT);
            bufferSize += FILE_READ_INCREMENT;
        }
    } while ((bytesRead = fread(buffer + totalBytesRead, 1, bufferSize - totalBytesRead, file)) != 0);

    if (path) {
        fclose(file);
    }

    *sizeOut = totalBytesRead;
    return buffer;
}

static int write_file(char* path, void* data, size_t size) {
    FILE* file = path ? fopen(path, "wb") : stdout;
    if (!file) {
        fprintf(stderr, "Error: Unable to open file %s for writing\n", path);
        return 0;
    }

    size_t written = fwrite(data, 1, size, file);
    if (written != size) {
        fprintf(stderr, "Error: Failed to write all data to file %s\n", path);
        fclose(file);
        return 0;
    }

    if (path) {
        fclose(file);
    }
    return 1;
}

static void* decompress(uint32_t* data, size_t sizeBytes, size_t* sizeOut) {
    if (sizeBytes % sizeof(data[0]) != 0) {
        fprintf(stderr, "Error: Source buffer not %lu-byte aligned\n", sizeof(data[0]));
        return 0;
    }

    size_t size = sizeBytes / sizeof(data[0]);

    if (size <= 5) {
        fprintf(stderr, "Error: Source buffer too small\n");
        return 0;
    }

    if (data[0] != CPRS_SIG || data[size - 1] != CPRS_SIG) {
        fprintf(stderr, "Error: CPRS signature check failed\n");
        return 0;
    }

    uint32_t compressedSize = data[1];
    uint32_t decompressedSize = data[2];

    void* buffer = malloc(decompressedSize);
    memset(buffer, 0, decompressedSize);

    uint32_t alpha = data[3];
    uint32_t beta = data[4];

    uint32_t remainingShifts = 0x20;
    uint32_t currentValue = 0;

    uint32_t* readCursor = data + 5;
    uint32_t* writeCursor = buffer;

    uint32_t index = 0;

    /*  I don't fully understand this and don't really need to.

        It's just a tidied up decompilation of the decompression
        function found in the internal flash of a Seagate/LSI MCU.

        It's definitely not safe currently, there's absolutely no
        bounds checking.
     */

    uint32_t* dst = buffer;
    uint32_t carry;

    while (1) {
        uint32_t extraBits;

        if ((alpha & 1) == 0) {
            extraBits = alpha >> 9;
            remainingShifts -= 9;
            carry = alpha >> 1 & 0xff;
            alpha = index & 3;
            index += 1;
            *(uint8_t*)((size_t)&currentValue + alpha) = (uint8_t)carry;
            if ((index & 3) == 0) {
                *dst = currentValue;
                dst += 1;
                currentValue = 0;
            }
        } else {
            uint32_t uVar9 = *(uint32_t*)(CPRS_TABLE + (alpha >> 1 & 3) * 0x10);
            uint32_t uVar1 = (alpha >> 3) >> (uVar9 & 0xff);
            uint32_t uVar5 = uVar1 >> 4;
            uint32_t* puVar2 = (uint32_t*)(CPRS_TABLE + (uVar1 & 0xf) * 0x10 + 0x40);
            uVar1 = *puVar2;
            extraBits = uVar5 >> (uVar1 & 0xff);
            remainingShifts -= uVar9 + 7 + uVar1;
            int iVar7 = puVar2[2] + ((1 << (uVar1 & 0xff)) - 1U & uVar5);
            if (iVar7 >= CPRS_TERM) {
                break;
            }
            int iVar6 = *(uint32_t*)((size_t)(CPRS_TABLE + (alpha >> 1 & 3) * 0x10) + 8)
                + ((1 << (uVar9 & 0xff)) - 1U & alpha >> 3)
                + ((int)(puVar2[1] + 0xb + ((uint32_t)((int)(puVar2[1] + 0xb) >> 0x1f) >> 0x1d)) >> 3);
            if (iVar7 == 0) {
                while (iVar6--) {
                    alpha = index & 3;
                    index += 1;
                    *(uint8_t*)((size_t)&currentValue + alpha) = (uint8_t)carry;
                    if ((index & 3) == 0) {
                        *dst = currentValue;
                        currentValue = 0;
                        dst = dst + 1;
                    }
                }
            } else {
                uint8_t* start = (uint8_t*)((size_t)writeCursor + iVar7 * -2 + index);
                for (int i = 0; i < iVar6; ++i) {
                    if (((uint32_t)(iVar7 * 2) < 4) && ((index & 3) != 0)) {
                        *dst = currentValue;
                    }
                    alpha = index & 3;
                    carry = (uint32_t)start[i];
                    index += 1;
                    *(uint8_t*)((size_t)&currentValue + alpha) = start[i];
                    if ((index & 3) == 0) {
                        *dst = currentValue;
                        dst += 1;
                        currentValue = 0;
                    }
                }
            }
        }

        if ((int)remainingShifts < 0) {
            remainingShifts = remainingShifts + 0x20;
            extraBits = beta >> (0x20 - remainingShifts & 0xff);
            beta = *readCursor;
            readCursor += 1;
        }
        alpha = beta << (remainingShifts & 0xff) | extraBits;
    }

    if ((index & 3) != 0) {
        *dst = currentValue;
    }
    if (sizeOut) {
        *sizeOut = index;
    }
    return buffer;
}

static const uint8_t CPRS_TABLE[768] = {
    0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,
    0x0a, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x0c, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
    0x43, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
    0x44, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x0b, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00,
    0x03, 0x02, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
    0x04, 0x02, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
    0x0e, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00,
    0x0b, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x04, 0x08, 0x00, 0x00,
    0x03, 0x10, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
    0x04, 0x10, 0x00, 0x00, 0x03, 0x20, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
    0x11, 0x00, 0x00, 0x00, 0x04, 0x20, 0x00, 0x00, 0x03, 0x40, 0x00, 0x00,
    0x0e, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00,
    0x03, 0x80, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
    0x04, 0x80, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
    0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
    0x00, 0x20, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x24, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
    0x20, 0x01, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00,
    0x00, 0x09, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00,
    0x00, 0x48, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00,
    0x90, 0x24, 0x00, 0x00, 0x00, 0x09, 0x01, 0x00, 0x49, 0x43, 0x00, 0x00,
    0x91, 0x00, 0x00, 0x00, 0x24, 0x90, 0x01, 0x00, 0x99, 0x25, 0x00, 0x00,
    0x41, 0x19, 0x05, 0x00, 0x4b, 0xd3, 0x05, 0x00, 0x01, 0x41, 0x00, 0x00,
    0x01, 0x80, 0x00, 0x00, 0x80, 0xb0, 0x00, 0x00, 0x94, 0x2c, 0x08, 0x00,
    0x08, 0x43, 0x01, 0x00, 0x83, 0xd1, 0x04, 0x00, 0xb5, 0x80, 0x08, 0x00,
    0xad, 0xf8, 0x03, 0x00, 0xd5, 0xad, 0x0c, 0x00, 0xdb, 0xf7, 0x04, 0x00,
    0x01, 0x09, 0x01, 0x00, 0x49, 0xd3, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00,
    0x24, 0x99, 0x00, 0x00, 0xd0, 0x66, 0x00, 0x00, 0xd0, 0x19, 0x05, 0x00,
    0x6f, 0x43, 0x04, 0x00, 0x98, 0x64, 0x00, 0x00, 0x40, 0x99, 0x05, 0x00,
    0xcb, 0x63, 0x05, 0x00, 0x95, 0x6d, 0x08, 0x00, 0x09, 0xc3, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xb5, 0x02, 0xc6, 0x00, 0x6b, 0x01, 0x8c, 0x01,
    0x7b, 0x03, 0xce, 0x01, 0x21, 0x00, 0x94, 0x02, 0x42, 0x00, 0x29, 0x01,
    0x31, 0x02, 0xad, 0x01, 0x84, 0x00, 0x52, 0x02, 0xd6, 0x02, 0x18, 0x03,
    0x4a, 0x01, 0x10, 0x02, 0xf7, 0x02, 0x9c, 0x03, 0xde, 0x03, 0x73, 0x02,
    0xe7, 0x00, 0xbd, 0x03, 0x63, 0x00, 0x5a, 0x03, 0x39, 0x03, 0xef, 0x01,
    0x08, 0x01, 0xa5, 0x00, 0xaa, 0x02, 0x55, 0x01, 0x5b, 0x02, 0x72, 0x03,
    0xe5, 0x02, 0xb7, 0x00, 0x00, 0x02, 0x10, 0x00, 0xcf, 0x02, 0xf6, 0x01,
    0xec, 0x03, 0x9f, 0x01, 0xdc, 0x02, 0x96, 0x03, 0x3e, 0x03, 0xd9, 0x03,
    0x6e, 0x01, 0xcb, 0x01, 0x67, 0x03, 0xfb, 0x00, 0x20, 0x00, 0x01, 0x00,
    0x80, 0x00, 0x04, 0x00, 0x00, 0x01, 0x08, 0x00, 0x2d, 0x03, 0xb9, 0x01,
    0x40, 0x00, 0x02, 0x00, 0xb3, 0x03, 0x7d, 0x02, 0x60, 0x01, 0x1d, 0x02,
    0x0b, 0x00, 0xb0, 0x03, 0x11, 0x01, 0x24, 0x00, 0x28, 0x02, 0x81, 0x00,
    0x9b, 0x01, 0x35, 0x03, 0x6c, 0x03, 0xb9, 0x02, 0xb6, 0x00, 0xd5, 0x02,
    0xc5, 0x02, 0xb6, 0x02, 0x85, 0x01, 0xe3, 0x01, 0xac, 0x00, 0x6f, 0x00,
    0xa2, 0x02, 0xb5, 0x03, 0x55, 0x00, 0xbd, 0x02, 0x92, 0x01, 0x69, 0x02,
    0x4c, 0x02, 0x33, 0x01, 0xf4, 0x01, 0xf5, 0x02, 0x8f, 0x02, 0xb7, 0x02
};
